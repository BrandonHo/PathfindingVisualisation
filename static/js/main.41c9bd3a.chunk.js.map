{"version":3,"sources":["helpers/constants.js","components/navbar.js","helpers/gridHelper.js","components/node.js","components/gridTable.js","helpers/visualiseAlgorithmHelper.js","algorithms/dfs.js","algorithms/bfs.js","helpers/performAlgorithmHelper.js","App.js","reportWebVitals.js","index.js"],"names":["NavBar","clearGridCallback","algoButtonCallback","id","class","IconButton","href","color","role","type","className","onClick","ConstantHelper","createGridNode","rowIndex","colIndex","isStartNode","isEndNode","isObstacle","isVisited","previousNode","getIndicesFromRandomNodeInGrid","grid","row","col","randomNode","Math","floor","random","length","constructGrid","rowCount","colCount","newGrid","currentRow","push","constructNewGridWithObstacleToggle","oldGrid","toggleRowIndex","toggleColIndex","slice","toggleNode","constructNewGridWithReset","currentNode","document","getElementById","selectStartNode","startNodeIndices","selectEndNode","endNodeIndices","Node","onMouseDown","extraNodeClassName","onMouseEnter","GridTable","gridData","handleMouseDown","map","node","nodeIndex","timeoutsForVisualisingAlgorithm","visualiseAlgorithm","visitedNodesOrdered","nodesFromPathToEndNode","i","timeoutForVisitedNode","setTimeout","visualiseVisitedNodes","timeoutToStartEndPathVisualisation","timeoutForNodeFromPathToEndNode","visualiseNodesFromPathToEndNode","clearTimeouts","timeoutIndex","clearTimeout","DFS","checkNode","unshift","PerformDFS","tryAddNeighbourNode","helperQueue","neighbourNode","tryGetNonVisitedNode","getNodesFromPathToEndNode","endNode","resultPath","PerformBFS","shift","performAlgorithm","algorithmCommand","result","DFSHelper","BFSHelper","App","mounted","useRef","useState","setVisitedNodesOrdered","setNodesFromPathToEndNode","isVisualisingAlgorithm","setVisualiseAlgorithmStatus","setStartNodeIndices","setEndNodeIndices","setGrid","useEffect","current","VisualiseAlgorithmHelper","GridHelper","buttonCommandString","PerformAlgorithmHelper","selectedRowIndex","selectedColIndex","updatedGrid","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.41c9bd3a.chunk.js","sourcesContent":["const COMMAND_RESET_GRID = \"reset\";\r\nconst COMMAND_ALGO_DFS = \"dfs\";\r\nconst COMMAND_ALGO_BFS = \"bfs\";\r\n\r\nconst INITIAL_TIME_MULTIPLIER_VISITED_NODES = 10;\r\nconst INITIAL_TIME_MULTIPLIER_END_NODE_PATH = 5;\r\n\r\nexport default\r\n{\r\n    COMMAND_RESET_GRID,\r\n    COMMAND_ALGO_DFS,\r\n    COMMAND_ALGO_BFS,\r\n    INITIAL_TIME_MULTIPLIER_VISITED_NODES,\r\n    INITIAL_TIME_MULTIPLIER_END_NODE_PATH\r\n}","import ConstantHelper from '../helpers/constants';\r\nimport IconButton from '../../node_modules/@material-ui/core/IconButton';\r\nimport GithubIcon from '../../node_modules/@material-ui/icons/GitHub';\r\nimport LinkedinIcon from '../../node_modules/@material-ui/icons/LinkedIn';\r\n\r\nfunction NavBar({clearGridCallback, algoButtonCallback})\r\n{   \r\n    return (\r\n    <nav id=\"navbar\" class=\"navbar fixed-top navbar-dark bg-dark justify-content-between\">\r\n\r\n        <div>\r\n            <a class=\"navbar-brand ms-3 h1\">React Pathfinding Visualiser</a>\r\n\r\n            <IconButton\r\n                 href=\"https://github.com/BrandonHo\"\r\n                 color=\"inherit\">\r\n                <GithubIcon/>\r\n            </IconButton>\r\n\r\n            <IconButton\r\n                 href=\"https://www.linkedin.com/in/brandon-ho-za/\"\r\n                 color=\"inherit\">\r\n                <LinkedinIcon/>\r\n            </IconButton>\r\n            \r\n        </div>\r\n        \r\n        <div class=\"btn-toolbar\" role=\"toolbar\">\r\n            <div class=\"btn group mr-2\" role=\"group\">\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-secondary\"\r\n                    onClick={() => algoButtonCallback(ConstantHelper.COMMAND_ALGO_DFS)}>\r\n                    DFS\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-secondary\"\r\n                    onClick={() => algoButtonCallback(ConstantHelper.COMMAND_ALGO_BFS)}>\r\n                    BFS\r\n                </button>\r\n            </div>\r\n            <div class=\"btn group mr-2\" role=\"group\">\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-danger\"\r\n                    onClick={() => clearGridCallback()}>\r\n                    Reset Grid\r\n                </button>\r\n            </div>\r\n        </div>\r\n    </nav>);\r\n}\r\n\r\nexport default NavBar;\r\n","function constructGrid(rowCount, colCount)\r\n{\r\n    const newGrid = [];\r\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++)\r\n    {\r\n        const currentRow = [];\r\n        for (let colIndex = 0; colIndex < colCount; colIndex++)\r\n            currentRow.push(createGridNode(rowIndex, colIndex));\r\n        newGrid.push(currentRow);\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nfunction createGridNode(rowIndex, colIndex)\r\n{\r\n    const newGridNode = \r\n    {\r\n        rowIndex: rowIndex,\r\n        colIndex: colIndex,\r\n        isStartNode: false,\r\n        isEndNode: false,\r\n        isObstacle: false,\r\n        isVisited: false,\r\n        previousNode: null\r\n    };\r\n\r\n    return newGridNode;\r\n}\r\n\r\nfunction getIndicesFromRandomNodeInGrid(grid)\r\n{\r\n    let row;\r\n    let col;\r\n    let randomNode;\r\n\r\n    do {\r\n        row = Math.floor(Math.random() * grid.length);\r\n        col = Math.floor(Math.random() * grid[row].length);\r\n        randomNode = grid[row][col];\r\n\r\n    } while (randomNode === null || randomNode.isEndNode || randomNode.isStartNode || randomNode.isObstacle);\r\n\r\n    return {\r\n        rowIndex: row,\r\n        colIndex: col\r\n    };\r\n}\r\n\r\nfunction selectStartNode(grid)\r\n{\r\n    let startNodeIndices = getIndicesFromRandomNodeInGrid(grid);\r\n    grid[startNodeIndices.rowIndex][startNodeIndices.colIndex].isStartNode = true;\r\n    return startNodeIndices;\r\n}\r\n\r\nfunction selectEndNode(grid)\r\n{\r\n    let endNodeIndices = getIndicesFromRandomNodeInGrid(grid);\r\n    grid[endNodeIndices.rowIndex][endNodeIndices.colIndex].isEndNode = true;\r\n    return endNodeIndices;\r\n}\r\n\r\nfunction constructNewGridWithObstacleToggle(oldGrid, toggleRowIndex, toggleColIndex)\r\n{\r\n    // Copy contents from old grid...\r\n    const newGrid = oldGrid.slice();\r\n\r\n    // ... then toggle the selected node\r\n    const toggleNode = newGrid[toggleRowIndex][toggleColIndex];\r\n    if (!toggleNode.isStartNode && !toggleNode.isEndNode)\r\n        toggleNode.isObstacle = !toggleNode.isObstacle;\r\n    \r\n    return newGrid;\r\n}\r\n\r\nfunction constructNewGridWithReset(oldGrid)\r\n{\r\n    // Copy contents from old grid...\r\n    const newGrid = oldGrid.slice();\r\n\r\n    // Reset visitation status for each node + reset class name (to reset styling)\r\n    for (let rowIndex = 0; rowIndex < oldGrid.length; rowIndex++)\r\n    {\r\n        for (let colIndex = 0; colIndex < oldGrid[rowIndex].length; colIndex++)\r\n        {\r\n            const currentNode = newGrid[rowIndex][colIndex];\r\n            currentNode.isVisited = false;\r\n            currentNode.isObstacle = false;\r\n\r\n            if (!currentNode.isStartNode && !currentNode.isEndNode)\r\n                document.getElementById(`node-${currentNode.rowIndex}-${currentNode.colIndex}`).className = \"node\";\r\n        }\r\n    }\r\n    \r\n    return newGrid;\r\n}\r\n\r\nexport default {\r\n    constructGrid,\r\n    constructNewGridWithObstacleToggle,\r\n    constructNewGridWithReset,\r\n    getIndicesFromRandomNodeInGrid,\r\n    selectStartNode,\r\n    selectEndNode\r\n};","import './node.css';\r\n\r\nconst Node = ({rowIndex, colIndex, isStartNode, isEndNode, isObstacle, isVisited, onMouseDown, onMouseEnter}) =>\r\n{\r\n    const extraNodeClassName = isEndNode? 'node-end'\r\n    : isStartNode? 'node-start'\r\n    : isObstacle? 'node-obstacle'\r\n    : '';\r\n\r\n    return (<td\r\n        id={`node-${rowIndex}-${colIndex}`}\r\n        className={`node ${extraNodeClassName}`}\r\n        onMouseDown={() => onMouseDown(rowIndex, colIndex)}\r\n    ></td>);\r\n}\r\n\r\nexport default Node;\r\n","import Node from '../components/node';\r\n\r\nconst GridTable = ({gridData, handleMouseDown}) =>\r\n(\r\n    <table className=\"no-spacing\">\r\n        <tbody>\r\n            {gridData.map((row, rowIndex) =>\r\n                {\r\n                    return (\r\n                        <tr key={rowIndex}>\r\n                            {row.map((node, nodeIndex) =>\r\n                            {\r\n                                const {rowIndex, colIndex, isStartNode, isEndNode, isVisited, isObstacle} = node;\r\n                                return (\r\n                                    <Node\r\n                                        key={nodeIndex}\r\n                                        rowIndex={rowIndex}\r\n                                        colIndex={colIndex}\r\n                                        isStartNode={isStartNode}\r\n                                        isEndNode={isEndNode}\r\n                                        isVisited={isVisited}\r\n                                        isObstacle={isObstacle}\r\n                                        onMouseDown={(rowIndex, colIndex) => handleMouseDown(rowIndex, colIndex)}\r\n                                    />\r\n                                );\r\n                            })}\r\n                        </tr>\r\n                    );\r\n                }\r\n            )}\r\n        </tbody>\r\n    </table>\r\n)\r\n\r\nexport default GridTable;","import ConstantHelper from './constants';\r\n\r\nlet timeoutsForVisualisingAlgorithm = [];\r\n\r\nfunction visualiseAlgorithm(visitedNodesOrdered, nodesFromPathToEndNode)\r\n{\r\n    // Clear array to store all new timeouts constructed for visualising the algorithm\r\n    timeoutsForVisualisingAlgorithm = [];\r\n\r\n    visualiseVisitedNodes(visitedNodesOrdered);\r\n\r\n    // Intialise timeout for visualising nodes from path to end node (starts after visited nodes visualised)\r\n    const timeoutToStartEndPathVisualisation = setTimeout(() => {\r\n        visualiseNodesFromPathToEndNode(nodesFromPathToEndNode);\r\n    }, ConstantHelper.INITIAL_TIME_MULTIPLIER_VISITED_NODES * visitedNodesOrdered.length);\r\n\r\n    timeoutsForVisualisingAlgorithm.push(timeoutToStartEndPathVisualisation);\r\n}\r\n\r\nfunction visualiseVisitedNodes(visitedNodesOrdered)\r\n{\r\n    for (let i = 0; i < visitedNodesOrdered.length; i++)\r\n    {\r\n        const timeoutForVisitedNode = setTimeout(() => {\r\n            const currentNode = visitedNodesOrdered[i];\r\n            \r\n            // Color all nodes in the array that were visited in the algorithm\r\n            if (!currentNode.isStartNode && !currentNode.isEndNode)\r\n                document.getElementById(`node-${currentNode.rowIndex}-${currentNode.colIndex}`).className = 'node node-visited';\r\n\r\n        }, ConstantHelper.INITIAL_TIME_MULTIPLIER_VISITED_NODES * i);\r\n\r\n        timeoutsForVisualisingAlgorithm.push(timeoutForVisitedNode);\r\n    }\r\n}\r\n\r\nfunction visualiseNodesFromPathToEndNode(nodesFromPathToEndNode)\r\n{\r\n    for (let i = 0; i < nodesFromPathToEndNode.length; i++)\r\n    {\r\n        const timeoutForNodeFromPathToEndNode = setTimeout(() => {\r\n            const node = nodesFromPathToEndNode[i];\r\n\r\n            // Color all nodes in the array that are in the end node path\r\n            if (!node.isStartNode && !node.isEndNode)\r\n                    document.getElementById(`node-${node.rowIndex}-${node.colIndex}`).className = 'node node-end-path';\r\n\r\n        }, ConstantHelper.INITIAL_TIME_MULTIPLIER_END_NODE_PATH * i);\r\n\r\n        timeoutsForVisualisingAlgorithm.push(timeoutForNodeFromPathToEndNode);\r\n    }\r\n}\r\n\r\nfunction clearTimeouts()\r\n{\r\n    for (let timeoutIndex = 0; timeoutIndex < timeoutsForVisualisingAlgorithm.length; timeoutIndex++)\r\n        clearTimeout(timeoutsForVisualisingAlgorithm[timeoutIndex]);\r\n}\r\n\r\nexport default {\r\n    visualiseAlgorithm,\r\n    clearTimeouts\r\n}","let nodesFromPathToEndNode = [];\r\nlet visitedNodesOrdered = [];\r\n\r\nfunction PerformDFS(grid, startNodeIndices)\r\n{\r\n    // Reset arrays that will store node data\r\n    visitedNodesOrdered = [];\r\n    nodesFromPathToEndNode = [];\r\n\r\n    DFS(grid, startNodeIndices.rowIndex, startNodeIndices.colIndex);\r\n\r\n    return {visitedNodesOrdered, nodesFromPathToEndNode};\r\n}\r\n\r\nfunction DFS(grid, rowIndex, colIndex)\r\n{\r\n    // Ignore invalid grid indices\r\n    if (rowIndex < 0 || rowIndex >= grid.length || colIndex < 0 || colIndex >= grid[rowIndex].length)\r\n        return null;\r\n\r\n    const currentNode = grid[rowIndex][colIndex];\r\n\r\n    // Ignore visited nodes\r\n    if (currentNode.isVisited)\r\n        return null;\r\n\r\n    // If found end node, then we have found a path to end node - stop.\r\n    if (currentNode.isEndNode)\r\n        return currentNode;\r\n\r\n    // Only deal with nodes that are non-obstacles or start nodes\r\n    if (!currentNode.isObstacle || currentNode.isStartNode)\r\n    {\r\n        // Update visited status + add to list of visited nodes\r\n        currentNode.isVisited = true;\r\n        visitedNodesOrdered.push(currentNode);\r\n\r\n        /*\r\n            Do DFS on neighbour nodes, which prioritises nodes in order of left, right\r\n            top, and bottom. Note: will only check the second neighbouring node if the\r\n            first neighbouring node path ended in a deadend (i.e null).\r\n        */\r\n\r\n        let checkNode = DFS(grid, rowIndex, colIndex - 1);\r\n        checkNode = (checkNode === null? DFS(grid, rowIndex, colIndex + 1) : checkNode);\r\n        checkNode = (checkNode === null? DFS(grid, rowIndex - 1, colIndex) : checkNode);\r\n        checkNode = (checkNode === null? DFS(grid, rowIndex + 1, colIndex) : checkNode);\r\n\r\n        // If check node defined, then we have a path to the end node\r\n        if (checkNode !== null)\r\n        {\r\n            nodesFromPathToEndNode.unshift(checkNode);\r\n            return currentNode;\r\n        }\r\n    }\r\n\r\n    // If we reached here, then all neighbouring nodes resulted in deadend - return null\r\n    return null;\r\n}\r\n\r\nexport default {\r\n    PerformDFS\r\n}","let visitedNodesOrdered = [];\r\nlet nodesFromPathToEndNode = [];\r\n\r\nfunction PerformBFS(grid, startNodeIndices)\r\n{\r\n    visitedNodesOrdered = [];\r\n    nodesFromPathToEndNode = [];\r\n\r\n    const helperQueue = [];\r\n    helperQueue.push(grid[startNodeIndices.rowIndex][startNodeIndices.colIndex]);\r\n\r\n    while (helperQueue.length)\r\n    {\r\n        const currentNode = helperQueue.shift();\r\n\r\n        if (currentNode.isEndNode)\r\n        {\r\n            nodesFromPathToEndNode = getNodesFromPathToEndNode(currentNode);\r\n            break;\r\n        }\r\n\r\n        if (currentNode.isVisited || currentNode.isObstacle)\r\n            continue;\r\n\r\n        if (currentNode.isStartNode || !currentNode.isVisited)\r\n        {\r\n            currentNode.isVisited = true;\r\n            visitedNodesOrdered.push(currentNode);\r\n\r\n            tryAddNeighbourNode(helperQueue, currentNode, grid, currentNode.rowIndex, currentNode.colIndex - 1);\r\n            tryAddNeighbourNode(helperQueue, currentNode, grid, currentNode.rowIndex, currentNode.colIndex + 1);\r\n            tryAddNeighbourNode(helperQueue, currentNode, grid, currentNode.rowIndex - 1, currentNode.colIndex);\r\n            tryAddNeighbourNode(helperQueue, currentNode, grid, currentNode.rowIndex + 1, currentNode.colIndex);\r\n        }\r\n    }\r\n\r\n    return {visitedNodesOrdered, nodesFromPathToEndNode};\r\n}\r\n\r\nfunction tryAddNeighbourNode(helperQueue, currentNode, grid, rowIndex, colIndex)\r\n{\r\n    const neighbourNode = tryGetNonVisitedNode(grid, rowIndex, colIndex);\r\n    if (neighbourNode !== null)\r\n    {\r\n        neighbourNode.previousNode = currentNode;\r\n        helperQueue.push(neighbourNode);\r\n    }\r\n}\r\n\r\nfunction tryGetNonVisitedNode(grid, rowIndex, colIndex)\r\n{\r\n    if (rowIndex < 0 || rowIndex >= grid.length || colIndex < 0 || colIndex >= grid[rowIndex].length)\r\n        return null;\r\n\r\n    if (grid[rowIndex][colIndex].isVisited)\r\n        return null;\r\n\r\n    return grid[rowIndex][colIndex];\r\n}\r\n\r\nfunction getNodesFromPathToEndNode(endNode)\r\n{\r\n    const resultPath = [];\r\n\r\n    while (endNode !== null)\r\n    {\r\n        resultPath.unshift(endNode);\r\n        endNode = endNode.previousNode;\r\n    }\r\n\r\n    return resultPath;\r\n}\r\n\r\nexport default {\r\n    PerformBFS\r\n}","import DFSHelper from '../algorithms/dfs';\r\nimport BFSHelper from '../algorithms/bfs';\r\nimport ConstantHelper from '../helpers/constants';\r\n\r\nfunction performAlgorithm(algorithmCommand, grid, startNodeIndices, endNodeIndices)\r\n{\r\n    var result = {};\r\n\r\n    // Perform the selected algorithm...\r\n    switch (algorithmCommand) {\r\n        case ConstantHelper.COMMAND_ALGO_DFS:\r\n            result = DFSHelper.PerformDFS(grid, startNodeIndices);\r\n            break;\r\n        case ConstantHelper.COMMAND_ALGO_BFS:\r\n            result = BFSHelper.PerformBFS(grid, startNodeIndices);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport default {\r\n    performAlgorithm\r\n}","import './App.css';\nimport React, {useState, useEffect, useRef} from 'react';\nimport NavBar from './components/navbar';\nimport GridHelper from './helpers/gridHelper';\nimport GridTable from './components/gridTable';\n\nimport VisualiseAlgorithmHelper from './helpers/visualiseAlgorithmHelper';\nimport PerformAlgorithmHelper from './helpers/performAlgorithmHelper';\n\nfunction App() {\n\n    const mounted = useRef();\n\n    const [visitedNodesOrdered, setVisitedNodesOrdered] = useState([]);\n    const [nodesFromPathToEndNode, setNodesFromPathToEndNode] = useState([]);\n    const [isVisualisingAlgorithm, setVisualiseAlgorithmStatus] = useState(false);\n\n    const [startNodeIndices, setStartNodeIndices] = useState({});\n    const [endNodeIndices, setEndNodeIndices] = useState({});\n    const [grid, setGrid] = useState([]);\n\n    useEffect(() => {\n\n        // Mimic componentDidMount\n        if (!mounted.current)\n        {\n            // Construct grid, select start + end nodes, then update state with grid\n            let grid = GridHelper.constructGrid(20, 20);\n            setStartNodeIndices(GridHelper.selectStartNode(grid));\n            setEndNodeIndices(GridHelper.selectEndNode(grid));\n            setGrid(grid);\n\n            mounted.current = true;\n        }\n        // Mimic componentDidUpdate\n        else\n        {\n            if (isVisualisingAlgorithm)\n                VisualiseAlgorithmHelper.visualiseAlgorithm(visitedNodesOrdered, nodesFromPathToEndNode);\n        }\n    });\n\n    const handleMouseDown = (selectedRowIndex, selectedColIndex) => {\n\n        if (isVisualisingAlgorithm)\n            return;\n\n        const updatedGrid = GridHelper.constructNewGridWithObstacleToggle(grid, selectedRowIndex, selectedColIndex);\n        setGrid(updatedGrid);\n    }\n\n    const clearGridCallback = () =>\n    {\n        // Clear any existing timeouts that are used for visualising algorithms + reset visualising status\n        VisualiseAlgorithmHelper.clearTimeouts();\n        setVisualiseAlgorithmStatus(false);\n\n        // Lastly, reset grid visit status + class names for nodes\n        setGrid(GridHelper.constructNewGridWithReset(grid));\n    }\n\n    const algoButtonCallback = (buttonCommandString) =>\n    {\n        // Only allow callbacks if not already visualising an algorithm\n        if (isVisualisingAlgorithm)\n            return;\n\n        // Object that will hold both visited nodes + nodes from to end node (from algorithm)\n        const result = PerformAlgorithmHelper.performAlgorithm(buttonCommandString, grid, startNodeIndices, endNodeIndices);\n        \n        // Update state with results + state to visualise algorithm\n        setVisitedNodesOrdered(result.visitedNodesOrdered);\n        setNodesFromPathToEndNode(result.nodesFromPathToEndNode);\n        setVisualiseAlgorithmStatus(true);\n    }\n\n    return (\n        <div className=\"App\">\n        <header className=\"App-header\">\n            <NavBar\n                clearGridCallback={clearGridCallback}\n                algoButtonCallback={algoButtonCallback}\n            />\n            <GridTable\n                gridData={grid}\n                handleMouseDown={handleMouseDown}\n            />\n        </header>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}